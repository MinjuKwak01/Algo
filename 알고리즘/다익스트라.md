### μµλ‹¨κ²½λ΅ μ•κ³ λ¦¬μ¦

μ—¬λ¬ κ°μ λ…Έλ“κ°€ μμ„ λ•, **νΉμ •ν• λ…Έλ“μ—μ„ μ¶λ°ν•μ—¬ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” κ°κ°μ μµλ‹¨κ²½λ΅λ¥Ό κµ¬ν•΄μ£Όλ” μ•κ³ λ¦¬μ¦**

μμ κ°„μ„ μ΄ μ—†μ„λ• μ •μƒμ μΌλ΅ λ™μ‘

1. μ¶λ° λ…Έλ“λ¥Ό μ„¤μ •ν•λ‹¤.
2. `μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”` μ΄κΈ°ν™”
3. λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ **`μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“ μ„ νƒ`**
4. ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ„ κ³„μ‚°ν•μ—¬ `μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”` κ°±μ‹ 
5. 3λ²κ³Ό 4λ²μ„ λ°λ³µ

- κ° λ…Έλ“μ— λ€ν• ν„μ¬κΉμ§€μ μµλ‹¨ κ±°λ¦¬ μ •λ³΄λ¥Ό ν•­μƒ **1μ°¨μ› λ¦¬μ¤νΈ**μ— μ €μ¥ν•λ©° λ¦¬μ¤νΈλ¥Ό κ³„μ† κ°±μ‹ ν•λ‹¤λ” νΉμ§•μ΄ μλ‹¤.
- λ§¤λ² μ²λ¦¬ν•κ³  μλ” λ…Έλ“λ¥Ό κΈ°μ¤€μΌλ΅ μ£Όλ³€ κ°„μ„  ν™•μΈ
- λ°©λ¬Έν•μ§€ μ•λ” λ…Έλ“ μ¤‘μ—μ„ ν„μ¬ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό ν™•μΈν•΄ κ·Έ λ…Έλ“μ— λ€ν•μ—¬ 4λ²μ„ μν–‰

ν• λ‹¨κ³„λ‹Ή ν•λ‚μ λ…Έλ“μ— λ€ν• μµλ‹¨ κ±°λ¦¬λ¥Ό ν™•μ‹¤ν μ°Ύλ” κ²ƒ

### 1. κ°„λ‹¨ν• λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦

O(V^2) β†’ Vλ” λ…Έλ“μ κ°μ

λ‹¨κ³„λ§λ‹¤ λ°λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•κΈ° μ„ν•΄ λ§¤ λ‹¨κ³„λ§λ‹¤ 1μ°¨μ› λ¦¬μ¤νΈμ λ¨λ“  μ›μ†λ¥Ό ν™•μΈ (μμ°¨νƒμƒ‰ν•λ‹¤)

`μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“` λ¥Ό μ°ΎκΈ° μ„ν•΄μ„ λ§¤λ² μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ μ„ ν•μ μΌλ΅ νƒμƒ‰ β†’ get_smallest_node()

```python
import sys
input = sys.stdin.readline
INF = int(1e9)

# λ…Έλ“ κ°μ, κ°„μ„  κ°μ
n, m = map(int, input().split())

# μ‹μ‘ λ…Έλ“ λ²νΈ
start = int(input())

# κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈ
graph = [[] for i in range(n+1)] #0λ²μ§Έλ” μ•μ”€

# λ°©λ¬Έν• μ μ΄ μ‡λ”μ§€ μ²΄ν¬ν•λ” λ©μ μ λ¦¬μ¤νΈ
visited = [False] * (n+1)

# μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
distance = [INF] * (n+1)

# λ¨λ“  κ°„μ„  μ •λ³΄ μ…λ ¥ λ°›κΈ°
for _ in range(m):
    # aλ² λ…Έλ“μ—μ„ bλ² λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ΄ c
    a, b, c = map(int, input().split())
    graph[a].append((b,c))

# λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“μ λ²νΈ λ°ν™
def get_smallest_node():
    min_value = INF
    index = 0
    for i in range(1, n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    distance[start] = 0
    visited[start] = True

    # j[0]μ€ λ…Έλ“ λ²νΈ, j[1]μ€ cost
    for j in graph[start]:
        distance[j[0]] = j[1]

    #μ‹μ‘ λ…Έλ“λ¥Ό μ μ™Έν• μ „μ²΄ n-1κ°μ λ…Έλ“μ— λ€ν•΄ λ°λ³µ
    for i in range(1, n):
        #ν„μ¬ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό κΊΌλ‚΄μ„, λ°©λ¬Έμ²λ¦¬
        now = get_smallest_node()
        visited[now] = True

        #ν„μ¬ λ…Έλ“μ™€ λ‹¤λ¥Έ μ—°κ²°λ λ…Έλ“ ν™•μΈ
        for j in graph[now]:
            cost = distance[now] + j[1]
            #ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³μ„ λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

# λ¨λ“  λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬ μ¶λ ¥
for i in range(1, n+1):
    # λ„λ‹¬ν•  μ μ—†λ” κ²½μ°, INFλΌκ³  μ¶λ ¥
    if distance[i] == INF:
        print("INF")
    else:
        print(distance[i])

# μ…λ ¥
# 6 11
# 1
# 1 2 2
# 1 3 5
# 1 4 1
# 2 3 3
# 2 4 2
# 3 2 3
# 3 6 5
# 4 3 3
# 4 5 1
# 4 3 1
# 5 6 2

# μ¶λ ¥
# 0
# 2
# 3
# 1
# 2
# 4
```

### 2. κ°μ„ λ λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦

`μµμ† ν™ κµ¬μ΅°` μ‚¬μ©

β†’ **κ°’μ΄ λ‚®μ€ λ°μ΄ν„°κ°€ λ¨Όμ € μ‚­μ  (λΉ„μ©μ΄ μ μ€ λ…Έλ“λ¥Ό μ°μ„ μ μΌλ΅ λ°©λ¬Έν•΄μ•Όν•κΈ° λ•λ¬Έ)**

`νΉμ • λ…Έλ“κΉμ§€μ μµλ‹¨κ±°λ¦¬μ— λ€ν• μ •λ³΄`λ¥Ό ν™μ— λ‹΄μ•„μ„ μ²λ¦¬

νμ΄μ¬ : PriorityQueue vs heapq β‡’ **`heapq`**κ°€ λ” λΉ λ¥΄λ‹¤.

<aside>
π’΅

μµμ† ν™μ„ μµλ€ ν™μ²λΌ μ‚¬μ©ν•λ” λ°©λ²• : κ°’μ— μμλ¥Ό λ¶™μ—¬μ„ λ„£μ—λ‹¤κ°€, λ‚μ¤‘μ— μ°μ„ μμ„ νμ—μ„ κΊΌλ‚Έ λ‹¤μμ— λ‹¤μ‹ μμ λ¶€νΈλ¥Ό λ¶™μ—¬μ„ μ›λμ κ°’μΌλ΅ λλλ¦¬λ©΄ λλ‹¤.

</aside>

ν™ μ‚½μ…, μ‚­μ  : O(logN)

`(κ±°λ¦¬, λ…Έλ“ λ²νΈ)` μμ„λ€λ΅ νν” λ°μ΄ν„°λ¥Ό κµ¬μ„±ν•΄ μ°μ„ μμ„ νμ— λ„£μΌλ©΄ κ±°λ¦¬ μμΌλ΅ μ •λ ¬λλ‹¤.

β‡’ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•κΈ° μ„ν•΄μ„λ” μ°μ„ μμ„ νμ—μ„ κ·Έλƒ¥ λ…Έλ“λ¥Ό κΊΌλ‚΄λ©΄ λλ‹¤.

(μ°μ„ μμ„ νμ—μ„ λ…Έλ“λ¥Ό κΊΌλ‚Έ λ’¤μ— ν•΄λ‹Ή λ…Έλ“λ¥Ό μ΄λ―Έ μ²λ¦¬ν• μ μ΄ μλ‹¤λ©΄ λ¬΄μ‹ν•κ³ , μ•„μ§ μ²λ¦¬ν•μ§€ μ•μ€ λ…Έλ“μ— λ€ν•΄μ„λ§ μ²λ¦¬ν•λ‹¤)

μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•λ” κ³Όμ •μ„ λ‹¤μµμ¤νΈλΌ μµλ‹¨ κ²½λ΅ ν•¨μ μ•μ—μ„ μ°μ„ μμ„ νλ¥Ό μ΄μ©ν•λ” λ°©μ‹μΌλ΅ λ€μ²΄

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

# λ…Έλ“ κ°μ, κ°„μ„  κ°μ
n, m = map(int, input().split())

# μ‹μ‘ λ…Έλ“ λ²νΈ
start = int(input())

# κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈ
graph = [[] for i in range(n+1)] #0λ²μ§Έλ” μ•μ”€

# λ°©λ¬Έν• μ μ΄ μ‡λ”μ§€ μ²΄ν¬ν•λ” λ©μ μ λ¦¬μ¤νΈ
visited = [False] * (n+1)

# μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
distance = [INF] * (n+1)

# λ¨λ“  κ°„μ„  μ •λ³΄ μ…λ ¥ λ°›κΈ°
for _ in range(m):
    # aλ² λ…Έλ“μ—μ„ bλ² λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ΄ c
    a, b, c = map(int, input().split())
    graph[a].append((b,c))

def dijkstra(start):
    q = []

    #μ‹μ‘ λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ²½λ΅λ” 0μΌλ΅ μ„¤μ •ν•μ—¬, νμ— μ‚½μ…
    heapq.heappush(q, (0, start))
    distance[start] = 0

    while q:
        # κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“μ— λ€ν• μ •λ³΄ κΊΌλ‚΄κΈ°
        dist, now = heapq.heappop(q)

        #ν„μ¬ λ…Έλ“κ°€ μ΄λ―Έ μ²λ¦¬λ μ μ΄ μλ” λ…Έλ“λΌλ©΄ λ¬΄μ‹
        if distance[now] < dist:
            continue
        #ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ μΈμ ‘ν• λ…Έλ“λ“¤μ„ ν™•μΈ
        for i in graph[now]:
            cost = dist + i[1]
            #ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³μ„, λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

dijkstra(start)

# λ¨λ“  λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬ μ¶λ ¥
for i in range(1, n+1):
    # λ„λ‹¬ν•  μ μ—†λ” κ²½μ°, INFλΌκ³  μ¶λ ¥
    if distance[i] == INF:
        print("INF")
    else:
        print(distance[i])

# μ…λ ¥
# 6 11
# 1
# 1 2 2
# 1 3 5
# 1 4 1
# 2 3 3
# 2 4 2
# 3 2 3
# 3 6 5
# 4 3 3
# 4 5 1
# 5 3 1
# 5 6 2

# μ¶λ ¥
# 0
# 2
# 3
# 1
# 2
# 4
```
