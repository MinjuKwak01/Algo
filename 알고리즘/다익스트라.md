### 최단경로 알고리즘

여러 개의 노드가 있을 때, **특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단경로를 구해주는 알고리즘**

음의 간선이 없을때 정상적으로 동작

1. 출발 노드를 설정한다.
2. `최단 거리 테이블` 초기화
3. 방문하지 않은 노드 중에서 **`최단 거리가 짧은 노드 선택`**
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 `최단 거리 테이블` 갱신
5. 3번과 4번을 반복

- 각 노드에 대한 현재까지의 최단 거리 정보를 항상 **1차원 리스트**에 저장하며 리스트를 계속 갱신한다는 특징이 있다.
- 매번 처리하고 있는 노드를 기준으로 주변 간선 확인
- 방문하지 않는 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인해 그 노드에 대하여 4번을 수행

한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것

### 1. 간단한 다익스트라 알고리즘

O(V^2) → V는 노드의 개수

단계마다 반문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인 (순차탐색한다)

`최단 거리가 짧은 노드` 를 찾기 위해서 매번 최단 거리 테이블을 선형적으로 탐색 → get_smallest_node()

```python
import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드 개수, 간선 개수
n, m = map(int, input().split())

# 시작 노드 번호
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트
graph = [[] for i in range(n+1)] #0번째는 안씀

# 방문한 적이 잇는지 체크하는 목적의 리스트
visited = [False] * (n+1)

# 최단 거리 테이블을 무한으로 초기화
distance = [INF] * (n+1)

# 모든 간선 정보 입력 받기
for _ in range(m):
    # a번 노드에서 b번 노드로 가는 비용이 c
    a, b, c = map(int, input().split())
    graph[a].append((b,c))

# 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드의 번호 반환
def get_smallest_node():
    min_value = INF
    index = 0
    for i in range(1, n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    distance[start] = 0
    visited[start] = True

    # j[0]은 노드 번호, j[1]은 cost
    for j in graph[start]:
        distance[j[0]] = j[1]

    #시작 노드를 제외한 전체 n-1개의 노드에 대해 반복
    for i in range(1, n):
        #현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문처리
        now = get_smallest_node()
        visited[now] = True

        #현재 노드와 다른 연결된 노드 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            #현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

# 모든 노드로 가기 위한 최단 거리 출력
for i in range(1, n+1):
    # 도달할 수 없는 경우, INF라고 출력
    if distance[i] == INF:
        print("INF")
    else:
        print(distance[i])

# 입력
# 6 11
# 1
# 1 2 2
# 1 3 5
# 1 4 1
# 2 3 3
# 2 4 2
# 3 2 3
# 3 6 5
# 4 3 3
# 4 5 1
# 4 3 1
# 5 6 2

# 출력
# 0
# 2
# 3
# 1
# 2
# 4
```

### 2. 개선된 다익스트라 알고리즘

`최소 힙 구조` 사용

→ **값이 낮은 데이터가 먼저 삭제 (비용이 적은 노드를 우선적으로 방문해야하기 때문)**

`특정 노드까지의 최단거리에 대한 정보`를 힙에 담아서 처리

파이썬 : PriorityQueue vs heapq ⇒ **`heapq`**가 더 빠르다.

<aside>
💡

최소 힙을 최대 힙처럼 사용하는 방법 : 값에 음수를 붙여서 넣었다가, 나중에 우선순위 큐에서 꺼낸 다음에 다시 음수 부호를 붙여서 원래의 값으로 되돌리면 된다.

</aside>

힙 삽입, 삭제 : O(logN)

`(거리, 노드 번호)` 순서대로 튜플 데이터를 구성해 우선순위 큐에 넣으면 거리 순으로 정렬된다.

⇒ 거리가 가장 짧은 노드를 선택하기 위해서는 우선순위 큐에서 그냥 노드를 꺼내면 된다.

(우선순위 큐에서 노드를 꺼낸 뒤에 해당 노드를 이미 처리한 적이 있다면 무시하고, 아직 처리하지 않은 노드에 대해서만 처리한다)

최단 거리가 가장 짧은 노드를 선택하는 과정을 다익스트라 최단 경로 함수 안에서 우선순위 큐를 이용하는 방식으로 대체

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드 개수, 간선 개수
n, m = map(int, input().split())

# 시작 노드 번호
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트
graph = [[] for i in range(n+1)] #0번째는 안씀

# 방문한 적이 잇는지 체크하는 목적의 리스트
visited = [False] * (n+1)

# 최단 거리 테이블을 무한으로 초기화
distance = [INF] * (n+1)

# 모든 간선 정보 입력 받기
for _ in range(m):
    # a번 노드에서 b번 노드로 가는 비용이 c
    a, b, c = map(int, input().split())
    graph[a].append((b,c))

def dijkstra(start):
    q = []

    #시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
    heapq.heappush(q, (0, start))
    distance[start] = 0

    while q:
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)

        #현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue
        #현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1]
            #현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

dijkstra(start)

# 모든 노드로 가기 위한 최단 거리 출력
for i in range(1, n+1):
    # 도달할 수 없는 경우, INF라고 출력
    if distance[i] == INF:
        print("INF")
    else:
        print(distance[i])

# 입력
# 6 11
# 1
# 1 2 2
# 1 3 5
# 1 4 1
# 2 3 3
# 2 4 2
# 3 2 3
# 3 6 5
# 4 3 3
# 4 5 1
# 5 3 1
# 5 6 2

# 출력
# 0
# 2
# 3
# 1
# 2
# 4
```
