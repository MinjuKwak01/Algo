“여러 개의 도시가 연결되어있다”, “서로 다른 객체”가 연결되어있다는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올리자.

그래프 구현 방법

1. 인접 행렬
2. 인접 리스트

노드의 개수가 V, 간선의 개수가 E 인 그래프를 생각해봤을때, 인접행렬을 이용하는 방식은 간선 정보를 저장하기 위해서 O(V^2) 만큼의 메모리 공간이 필요하다. 반면에 인접 리스트를 이용할때는 간선의 개수만큼인 O(E)만큼만 메모리 공간이 필요하다. 

어떤 문제를 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야 한다. 예를 들어 최단 경로를 찾아야 하는 문제가 출제되었을 때, 노드의 개수가 적은 경우에는 `플로이드 워샬 알고리즘`을 사용할 수 있다. 반면에 노드와 간선의 개수가 모두 많으면 우선순위 큐를 이용하는 `다익스트라 알고리즘`을 이용하면 유리하다.

서로소 집합

공통 원소가 없는 두 집합

ex) (1,2) 와 (3,4) / (1,2) 와 (2,3) → x

서로소 집합 자료구조 (union find 자료구조) : 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조

union 연산 : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산

find 연산 : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산

### 서로소 집합 자료구조

트리 자료구조를 이용하여 집합을 표현

서로소 집합 정보가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산

1. union (합집합) 연산을 확인하여 서로 연결된 두 노드 A, B를 확인한다.
    1. A와 B의 루트 노드 A’ B’를 각각 찾는다.
    2. A’ 를 B’의 부모 노드로 설정한다. (B’가 A’를 가리키도록 한다)
2. 모든 union (합집합) 연산을 처리할 때까지 1번 과정을 반복한다.

A’가 1이고 B’가 3이라면 `B’가 A’를 가리키도록` 설정 (가리킨다 : 부모 노드로 설정)

= 번호가 작은 원소가 부모노드가 되도록

B’가 A’를 부모 노드로 설정하는 것을 그래프로 시각화할 때 B’와 A’를 간선으로 연결하는 형태로 그래프를 그릴 수 있다.

예)

- union 1, 4
- union 2, 3
- union 2, 4
- union 5, 6

→ 4개의 union 연산이 수행된 후에 전체 원소들이 결과적으로 어떠한 형태의 부분집합으로 나누어질지 확인해보자

이러한 union 연산들은 그래프 형태로 표현될 수 있다. 

각 원소는 그래프에서의 노드로 표현되고, 같은 집합에 속한다는 정보를 담은 `union 연산들은 간선`으로 표현된다.

즉, 6개의 노드가 있고 4개의 간선이 존재하는 그래프로 바꿔서 생각할 수 있다.

**유의할 점**

실제로 각 원소의 집합 정보를 표현하려면 트리 자료구조를 이용한다. 일반적으로 서로소 집합을 그림으로 표현할 때는 `번호가 큰 노드가 번호가 작은 노드를 간선으로 가리키도록` 트리 구조를 이용해 그림을 그리게 된다.

![IMG_6504.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/70aafb0f-8ef5-4086-b5eb-afff12916062/2ce24b53-c6ef-42a0-a4d1-769dfc322634/IMG_6504.jpeg)

→ 전체 원소가 [1,2,3,4], [5,6] 이라는 두 집합으로 나누어진다.

→ 노드 1,2,3,4는 같은 집합에 속함, 노드 5, 6은 같은 집합에 속함

union 연산을 토대로 그래프를 그리면 연결성으로 손쉽게 집합의 형태를 확인할 수 있다.

노드 3에서 노드 1로 간접적으로 연결되어 이동할 수 있기 때문에 같은 집합에 있는 것으로 이해할 수 있다.

노드 1과 노드 5는 서로 연결되어있지 않기 때문에 서로 다른 집합으로 나누어져 있다.

union 연산을 하나씩 확인하면서 서로 다른 두 원소에 대해 합집합(union)을 수행해야 할 때는, 각각 루트 노드를 찾아서 `더 큰 루트 노드가 더 작은 루트 노드를 가리키도록` 하면 된다.

1. 가장 먼저 노드의 개수(V) 크기의 부모 테이블을 초기화한다.
    - 모든 원소가 자기 자신을 부모로 가지도록 설정한다.
    - 현재 원소의 개수가 6이므로, 초기 단계에서는 총 6개의 트리가 존재하는 것과 같다.
    
    유의할 점
    
    - 부모 테이블은 말 그대로 부모에 대한 정보만을 담고 있다. = 특정한 노드의 부모에 대해서만 저장하고 있다

```python
# 특정 원소가 속한 집합을 찾기
# 비효율적인 find_parent 함수 (최악 시간복잡도 : O(V))
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return parent[x]
    # x를 리턴 -> 일반
    # parent[x]를 리턴 -> 경로 압축

# 두 원소가 속합 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선 (union 연산)의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v+1) # 부모 테이블 초기화

# 부모 테이블 상에서, 부모를 자기 자신으로 초기화
for i in range(1, v+1):
    parent[i] = i

# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

print("각 원소가 속한 집합: ", end="")
for i in range(1, v+1):
    print(find_parent(parent, i), end=" ")

print()

# 부모 테이블 내용 출력
print("부모 테이블: ", end="")
for i in range(1, v+1):
    print(parent[i], end= " ")

# 입력
# 6 4
# 1 4
# 2 3
# 2 4
# 5 6
```
